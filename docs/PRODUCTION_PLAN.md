# MyStats 프로덕션 고도화 계획서 (Production Upgrade Plan)

> 목적: `mystats`를 **스토어 없이도 “프로덕션급 PWA 앱”**으로 런칭/운영 가능하게 만들고, 사용자가 늘어도 **안정성·비용·보안·데이터 신뢰성**을 유지한다.
>
> 기준일: 2026-01-24  
> 현재 배포(데모): https://mystats-eta.vercel.app/

---

## 0) TL;DR (요약)

- **단기(1~2주)**: 품질/운영 기반을 깔아 “깨져도 바로 알 수 있고”, “재현 가능하고”, “복구가 쉬운” 상태로 만든다.  
  (CI, 테스트 최소세트, Sentry, 데이터/백업 UX, PWA 업데이트 UX)
- **중기(2~6주)**: “어디서나” 경험을 위해 **옵션형 로그인 + 클라우드 동기화**를 붙인다(로컬 퍼스트 유지).  
  (Supabase Auth/DB + 동기화 큐 + 충돌 해결)
- **장기(6주~)**: “아무나 AI를 바로 쓰는” 구조가 필요하면 **서버리스 AI 프록시 + 비용 방어(요금제/쿼터/레이트리밋)**로 확장한다.  
  (Free=BYOK, Pro=내장 AI)

---

## 1) 현재 상태 (As-Is)

### 1.1 제품/배포
- Vercel + GitHub 연동 배포
- SPA 라우팅 + PWA 설치 지원(서비스워커/manifest)
- 스토어 배포 없이도 iOS/Android에서 “홈 화면에 추가/앱 설치” 가능

### 1.2 데이터/저장소
- **Local-first**: IndexedDB(idb) + fallback(localStorage/메모리)
- Export/Import(백업/복원) 기능 있음

### 1.3 AI
- BYOK(Bring Your Own Key): 사용자가 Settings에 API 키를 넣고 브라우저에서 직접 각 Provider 호출
- Provider: Gemini/OpenAI/Claude/Grok 선택 가능

### 1.4 메모리(memU)
- **내장(Embedded) memU 엔진**을 MyStats 내부에 포함
  - 저널(IndexedDB/fallback)을 메모리 소스로 사용
  - retrieve(top-K) / check-similar(유사도) 제공
  - Strategy 생성 시 memU 컨텍스트를 자동 주입 가능
- **서버(API) 모드** 옵션도 유지(로컬 memU 서버가 있으면 연결 가능)

---

## 2) 목표 (To-Be)

### 2.1 제품 목표
1. **설치/실행이 빠르고**(PWA), **오프라인에서도 기본 기능이 동작**
2. 데이터 손실/중복에 강하고, 사용자가 스스로 복구 가능(백업/복원/동기화)
3. 장애가 나면 “원인/영향/재현”이 가능한 운영 레벨(관측/로그/리포팅)
4. (선택) 누구나 AI 기능을 바로 쓰게 하되, 비용 폭탄 없이 운영(서버리스 프록시 + 요금제)

### 2.2 성공 지표(예시)
- 크래시/Unhandled error 비율 ↓, Sentry에서 원인 분류 가능
- “데이터 복구 성공률” ↑ (백업/복원 + 동기화)
- PWA 설치 전환율(Install prompt, iOS 안내 클릭) ↑
- AI 비용(토큰/요청) 예측 가능 + 과금 단위 정의 가능

---

## 3) 핵심 의사결정(Decision)

### 3.1 앱 형태
- **PWA 우선** (스토어 불필요)  
  - 운영/배포가 빠르고, 한 코드베이스로 웹+모바일을 커버
  - 단, iOS Safari의 PWA 제약(백그라운드 제한 등)은 UX로 보완

### 3.2 데이터 전략
- **Local-first 유지** + (옵션) **로그인 기반 클라우드 동기화**
  - 데모/라이트 사용자는 로그인 없이도 사용 가능
  - “기기 바뀌어도 동일 데이터”가 필요하면 로그인/동기화 제공

### 3.3 AI 전략(비용/보안)
- 기본은 BYOK 유지(서버 비용 0)
- 대중 런칭/유료화 시:
  - **서버리스 프록시에서만 LLM 호출**
  - 요금제/쿼터/레이트리밋으로 비용을 통제

---

## 4) 메모리 시스템(memU) 업데이트 상세

### 4.1 왜 내장(Embedded)인가?
- 런칭 초기에는 “서버를 운영하지 않아도” 메모리 검색/유사도 기능을 제공하는 게 중요
- 사용자 입장에서 설정/의존성이 줄어든다(설치/운영 장벽 ↓)

### 4.2 구성 요소
- `Embedded engine`:
  - 데이터 소스: `Journal`(IndexedDB) + fallback
  - 동작: 텍스트 → 해시 기반 벡터화 → 코사인 유사도
  - 제공 API: `retrieve`, `check-similar`
- `Server (API) engine`:
  - 기존 `memU` 서버와 REST로 통신(`/health`, `/retrieve`, `/check-similar`, `/items`)
  - Strategy에서 `project-registry`까지 포함 검색 옵션 제공

### 4.3 현재 한계/의도된 제약
- Embedded는 “프로젝트 레지스트리” 같은 외부 스코프 검색을 하지 않음(프라이버시/스코프 안전)
- 임베딩 품질은 “경량/오프라인/비용 0”에 최적화되어 있고, 필요 시 향후 고급 임베딩으로 업그레이드 가능

### 4.4 다음 개선(프로덕션)
- Web Worker로 임베딩/검색을 분리(긴 저널에서도 UI 프리징 방지)
- 벡터 캐싱/증분 인덱싱(매번 전체 재계산 방지)
- 저장 시 “유사 기록 경고/병합” UX(데이터 품질 ↑)

---

## 5) 작업 스트림(Workstreams) & 실행 순서

> 원칙: “사용자 체감 + 운영 리스크”가 큰 것부터 한다.

### WS-A) 운영/품질 기반 (가장 먼저)
**목표:** 깨지면 바로 감지/재현/복구 가능

1) CI 파이프라인 (GitHub Actions)
- `lint`, `build`, (가능하면) `test` 필수 체크
- PR 템플릿/체크리스트(릴리즈 노트/변경 영향)

2) 테스트 최소세트
- 유닛: DB(fallback 포함), memU embedded 로직, prompt 빌더
- e2e(Playwright): 저널 작성→저장→전략 생성, 백업/복원, 설정 저장

3) 에러/성능 관측
- Sentry(프론트) 도입: unhandled error + breadcrumb
- “리포트 보내기” UX(로그/환경/최근 액션)

**완료 기준(DoD)**
- main에 머지되면 빌드/린트/테스트가 자동으로 돌고, 실패 시 배포가 막힘
- 데모에서 주요 플로우 1~2개는 e2e로 보호됨

---

### WS-B) 데이터 신뢰성/복구 (사용자 체감 큼)
**목표:** “데이터가 내 자산”이라는 신뢰 확보

1) 백업/복원 강화
- 백업 포맷 버전 관리(스키마 변경에도 복구 가능)
- 중복/머지 정책 명확화(어떤 기준으로 합치는지 UI에 노출)

2) 마이그레이션/스키마 관리
- IndexedDB 스키마 버전/마이그레이션 경로 문서화
- “DB 초기화/복구” 흐름을 더 안전하게

3) 프라이버시 UX
- “이 데이터는 기기별 저장” 안내(로그인/동기화 전)
- (선택) 로컬 암호화(패스프레이즈) — 민감도 높으면 고려

---

### WS-C) 성능/UX (PWA의 완성도)
**목표:** 모바일에서 빠르고 부드럽게

1) memU embedded 성능
- Worker 전환 + 캐시/증분 인덱스
- 검색 결과 하이라이트/근거(어떤 기록이 왜 추천됐는지)

2) 번들/로딩
- 큰 페이지 lazy-load 유지/강화(이미 일부 chunking 있음)
- “업데이트 있음” 토스트(서비스워커 autoUpdate와 연동)

3) 접근성(A11y)
- 키보드 탐색, 색 대비, 폼 라벨/aria

---

### WS-D) “어디서나” 동기화 (선택이지만 장기적으로 핵심)
**목표:** 로그인하면 어떤 기기에서도 같은 데이터

권장 설계: **옵션형 Sync**
- 기본: 로컬 저장(즉시)
- 백그라운드: 변경 사항을 “sync queue”에 쌓고, 온라인일 때 업로드
- 충돌 해결: 최소는 last-write-wins, 고급은 필드 단위 머지

필수 구성
- Auth: Supabase Auth(이메일/매직링크)
- DB: Supabase Postgres(저널/스킬/인사이트 테이블)
- Sync: `pull`/`push` + cursor 기반 증분 동기화

---

### WS-E) AI를 대중에게 열기(유료화/비용 방어) — 옵션
**목표:** 사용자가 API 키 없이도 AI 기능 사용

권장 모델
- Free: BYOK + 로컬 기능
- Pro: 내장 AI(우리 키) + 월 사용량 제한 + 우선 모델

필수 방어 장치
- 서버리스 프록시에서만 호출(키는 서버에만)
- rate limit/쿼터(일/월), 입력 길이 제한
- abuse 탐지(짧은 시간 내 반복 호출 등)

---

## 6) 릴리즈/버전 전략

- SemVer: `MAJOR.MINOR.PATCH`
- 변경 기록: `CHANGELOG.md` 유지
- GitHub Release: 태그(`vX.Y.Z`) + 릴리즈 노트 자동화(추후)
- Vercel: main=production, PR=preview 배포 유지

---

## 7) 로드맵(제안)

### Milestone 1 (v1.2.x): “운영 가능한 PWA”
- CI + 최소 테스트 + Sentry
- 백업/복원 UX 강화
- memU embedded 성능(Worker/캐시) 1차

### Milestone 2 (v1.3.x): “어디서나 동일 데이터(옵션)”
- Auth + Cloud backup/sync (opt-in)
- 충돌 해결/동기화 상태 UI

### Milestone 3 (v2.0): “유료/대중 런칭(선택)”
- 서버리스 AI 프록시
- 요금제/쿼터/결제

---

## 8) 다음 액션(바로 실행)

1) **Milestone 1 범위 확정**: WS-A/WS-B에서 “이번 스프린트에 꼭” 할 항목 체크
2) CI/테스트 스캐폴딩부터 추가
3) Sentry 붙이고, 실제 에러를 수집하기 시작

